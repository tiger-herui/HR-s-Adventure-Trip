## 索引

：对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

## 数据访问方式

### 全表扫描 full table scan

对表中的数据一行一行地扫描；直接访问数据页；

#### 使用情况

1. like ‘%...%’，全模糊搜索
2. 不等于操作符（<>、!=）
3. Oracle 9i中，查询字段is null时单索引失效，引起全表扫描

### 索引扫描 index scan

在有聚集索引的情况下，clustered index scan就是table scan

#### 索引全扫描 index full scan

#### 索引范围扫描 index range scan

#### 索引唯一扫描 index unique scan



## 聚集索引设计指南

​	聚集索引根据**键值**对表中的数据行进行排序、存储。

​	每张表只能有一个聚集索引，因为标中的数据行只能按一种顺序排序（物理）。除少数特例外，每张表都应有一个聚集索引定义在一列或多列数据列上，这些索引作用于：

- 经常使用的查询

-  提供高度唯一性

> **NOTE**
>
> ​	当创建主键（PRIMARY KEY）约束时，会在表中一个或多个列上自动创建一个唯一的索引。默认情况下，此索引是聚集索引。同时，也可以在创建约束时指定非聚集索引。


​	在 SQL Server 中，索引结构被设计为B-Trees。B-Tree索引中的每一个记录都是一个索引节点。B-Tree的顶部节点称为根节点，底部节点称为叶节点。根节点和叶节点之间的任何索引统称为**中间级别**。在聚集索引中:

1. 叶节点包含基础表的数据记录；
2. 根节点和中间节点包含保存索引行的索引记录。（每个索引行包含一个键值和一个指针，指向叶级别中的数据行。索引的每一级记录都链接在一个双向链表中。）


> Sys.partitions：包含数据库中所有表和大多数索引的每个分区的行。

| Column name  | Data type  | Description                                                  |
| :----------- | :--------- | :----------------------------------------------------------- |
| partition_id | **bigint** | Indicates the partition ID. Is unique within a database.     |
| object_id    | **int**    | Indicates the ID of the object to which this partition belongs. Every table or view is composed of at least one partition. |
| index_id     | **int**    | Indicates the ID of the index within the object to which this partition belongs.  0 = heap 1 = clustered index 2 or greater = nonclustered index |




![LUtOYJoie73CGsF](https://i.loli.net/2021/10/24/LUtOYJoie73CGsF.gif)



### 查询注意事项

​	考虑对执行以下操作的查询使用聚集索引：

- 使用诸如`BETWEEN`、>、>=、< 和 <=等运算符返回一系列值


- 返回大型结果集

- 使用`JOIN`时，通常这些是外键列

- 使用`ORDER BY`或`GROUP BY`时。`ORDER BY` `或 GROUP BY` 子句中指定列上的索引可能不需要数据库引擎对数据进行排序，因为行已经排序。



### 列注意事项

通常，应该使用尽可能少的列来定义聚集索引键。考虑具有以下一项或多项属性的列：

- 是唯一的，包含许多不同的值

- 按顺序访问


- 表中经常需要排序的数据

不考虑以下列：


- 频繁更改的列：这会导致整行移动，因为数据库引擎必须按物理顺序保留行的数据值。在数据通常易变的大容量事务处理系统中，这是一个重要的考虑因素。

- 宽键



## 非聚集索引设计指南

​	非聚集索引包含指向表数据存储位置的索引键值和行定位符。您可以在一个表或索引视图上创建多个非聚集索引。通常，非聚簇索引的设计应旨在提高聚簇索引未涵盖的常用查询的性能。

​	查询优化器通过搜索非聚集索引来查找数据值，以查找数据值在表中的位置，然后直接从该位置检索数据。这使得非聚集索引成为精确匹配查询的最佳选择，因为该索引包含描述在查询中搜索的数据值在表中的确切位置的条目。

![98AMbjWhBTo6Gcx](https://i.loli.net/2021/11/01/98AMbjWhBTo6Gcx.gif)




### 非聚集索引架构

非聚集索引与聚集索引具有相同的B树结构，但存在以下差异：

- 表的数据行不会根据其非聚集键来顺序排序和存储
- 非聚集索引的叶级由索引记录组成（而不是数据记录组成）

非聚集索引行中的行定位器要么是指向行的指针，要么是行的聚集索引键，如下所述：

- 如果表是堆，这意味着它没有聚集索引，则行定位器是指向该行的指针。指针是根据文件标识符 (ID)、页码？？和页上的行号构建的。整个指针称为**RowID (RID)**。
- 如果表具有聚集索引，或者索引位于索引视图上??，则行定位符是该行的聚集索引键。



### 数据库注意事项

设计非聚集索引时要考虑数据库的特性。

  主要包含只读数据的决策支持系统应用和数据库可以从非聚集索引中受益。查询优化器有更多的索引可供选择，以确定最快的访问方式，数据库的低更新特性意味着索引维护不会影响性能。

  表上的大量索引会影响 INSERT、UPDATE、DELETE 和 MERGE 语句的性能，因为所有索引都必须随着表中数据的变化而适当调整。



### 查询注意事项

考虑对具有以下属性的查询使用非聚集索引：

- 使用`JOIN`或`GROUP BY`：在此涉及的列上创建多个非聚集索引，并在任何一个外建列上创建聚集索引

- 不返回大结果集的查询：创建过滤索引以涵盖从大表中返回定义明确的行子集的查询


> 通常，CREATE INDEX 语句的 WHERE 子句与所涵盖查询的 WHERE 子句匹配。

- 包含经常涉及查询条件的列：如返回完全匹配的 WHERE 子句

> 在添加新索引时考虑成本与收益。最好将额外的查询需求合并到现有索引中。例如，考虑向现有索引添加一两个额外的叶级列，如果它允许覆盖多个关键查询，而不是每个关键查询都有一个完全覆盖索引。

### 列注意事项

考虑具有以下一项或多项属性的列：

- 覆盖查询：当索引包含查询中的所有列时，可以获得性能提升，查询优化器可以定位索引内的所有列值，不访问表或聚集索引数据，从而减少磁盘 I/O 操作。使包含列的索引来添加覆盖列，而不是创建宽索引键。如果表有聚集索引，聚集索引中定义的一列或多列会自动附加到表上每个非聚集索引的末尾。

- 聚集索引用于其他列，且该列有许多不同的值：例如姓氏和名字的组合。



### 使用包含列扩展非聚集索引


​	通过将非键列添加到非聚集索引的叶级来扩展非聚集索引的功能。通过包含非键列，您可以创建涵盖更多查询的非聚集索引。这是因为非键列具有以下优点：

- 它们可以是不允许作为索引键列的数据类型。

- 在计算索引键列数或索引键大小时，数据库引擎不会考虑它们。




### 使用包含列来避免大小限制

​	在非聚集索引中包含非键列，以避免超过当前索引大小限制（最多 16 个键列和 900 字节的最大索引键大小）。数据库引擎在计算索引键列数或索引键大小时不考虑非键列。
​	假设要为表中的以下列建立索引`Document`：

- `Title nvarchar(50)`

- `Revision nchar(5)`

- `FileName nvarchar(400)`


```sql
CREATE INDEX IX_Document_Title
ON Production.Document (Title, Revision)
INCLUDE (FileName);
```



### 包含列的索引指南

- 非键列在 CREATE INDEX 语句的 INCLUDE 子句中定义。

- 非键列只能在表或索引视图的非聚集索引上定义。

- 允许除**text**、**ntext**和**image**之外的所有数据类型。

- 与键列一样，从**image**、**ntext**和**text**数据类型派生的计算列可以是非键（包含）列，只要允许计算列数据类型作为非键索引列即可。

- 不能同时在 INCLUDE 列表和键列列表中指定列名。

- 列名不能在 INCLUDE 列表中重复。

  

### 列大小指南

- 必须至少定义一个键列。非键列的最大数量为 1023 列。这是表列的最大数量减 1。
- 索引键列（非键除外）必须遵循现有索引大小限制，即最多 16 个键列，总索引键大小为 900 字节。
- 所有非键列的总大小仅受 INCLUDE 子句中指定的列大小的限制；例如，**varchar(max)**列限制为 2 GB。



### 列修改指南

当您修改已定义为包含列的表列时，以下限制适用：

- 除非先删除索引，否则不能从表中删除非键列。

- 不能更改非键列，除非执行以下操作：

  - 增加**varchar**、**nvarchar**或**varbinary**列的长度。

     笔记

    这些列修改限制也适用于索引键列。



### 设计建议

​	重新设计具有较大索引键大小的非聚集索引，以便仅用于搜索和查找的列是键列。使覆盖查询的所有其他列都包含非键列。通过这种方式，您将拥有覆盖查询所需的所有列，但索引键本身
又小又高效。

​	假设要设计一个索引来覆盖以下查询。

```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode
FROM Person.Address
WHERE PostalCode BETWEEN N'98000' and N'99999';
```

​	为了覆盖查询，必须在索引中定义每一列。尽管您可以将所有列定义为键列，但键大小将为 334 字节。由于实际用作搜索条件的唯一列是`PostalCode`长度为 30 字节的列，因此更好的>索引设计将定义`PostalCode`为键列，并将所有其他列包括为非键列。

​	以下语句创建一个包含列的索引以覆盖查询。

```sql
CREATE INDEX IX_Address_PostalCode
ON Person.Address (PostalCode)
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);
```



### 性能注意事项

避免添加不必要的列。添加过多的索引列（键或非键）可能会对性能产生以下影响：

- 更少的索引行将适合一个页面。这可能会增加 I/O 并降低缓存效率。
- 将需要更多磁盘空间来存储索引。特别是，将**varchar(max)**、**nvarchar(max)**、**varbinary(max)**或**xml**数据类型添加为非键索引列可能会显着增加磁盘空间要求。这是因为列值被
复制到索引叶级别。因此，它们驻留在索引和基表中。
- 索引维护可能会增加对基础表或索引视图执行修改、插入、更新或删除所需的时间。

您必须确定查询性能的提升是否大于数据修改期间和额外磁盘空间需求对性能的影响。
