# 1 内存模型

​	计算机在执行程序时，每条指令都是在 CPU 中执行的，而执行指令过程中，势必涉及到数据的读取和写入。

​	由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，**这时就存在一个问题**：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。

​	因此，在 CPU 里面就有了高速缓存（寄存器）。也就是说，在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

## 1.1 缓存一致性问题

```java
i = i + 1;
```

**过程：**当线程执行这个语句时

1. 会先从主存当中读取 i 的值；
2. 然后复制一份到高速缓存当中；
3. 然后CPU执行指令对 i 进行加1操作；
4. 然后将数据写入高速缓存；
5. 最后将高速缓存中 i 最新的值刷新到主存当中。

　　这个代码在单线程中运行是没有任何问题的（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的），但是在在多核 CPU 中，每个线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存。

​	初始时，两个线程分别读取 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程1 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是 0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。

　　最终结果 i 的值是 1，而不是 2 。**也就是说，如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在 缓存不一致的问题。**

## 1.2 解决方法（硬件层面）

### 总线加LOCK#锁

​	在软件层面，效果等价于使用 synchronized 关键字。

​	因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。

### 缓存一致性协议 

​	在软件层面，效果等价于使用 volatile 关键字。
​	最出名的就是 Intel 的 **MESI 协议**。MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是： 当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态。因此，当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。

## 1.3 并发

### 1.3.1 原子性问题

 **即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**

​	假若一个线程执行到这个语句时，我们暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取 i 的值，那么读取到的就是错误的数据，导致 **数据不一致性** 问题。

### 1.3.2 可见性问题

**是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。**

### 1.3.3 有序性问题

**即程序执行的顺序按照代码的先后顺序执行。**

**指令重排序**：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的（单线程情形下）。



# 2 java内存模型

1. 在 Java 中，对基本数据类型的变量的 读取 和  赋值 操作是原子性操作，即这些操作是不可被中断的 ： 要么执行，要么不执行

2. 对于可见性，Java 提供了 volatile关键字 来保证可见性。

3. 允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

## 2.1 volatile

​	一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰后，那么就具备了两层语义：

1. 保证了不同线程对**共享变量**进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 立即可见 的；

2. 禁止进行指令重排序。

## 2.2 volatile使用场景

​	synchronized 关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率；而 volatile 关键字在某些情况下性能要优于 synchronized，**但是要注意 volatile 关键字是无法替代 synchronized 关键字的，因为 volatile 关键字无法保证操作的原子性。**



通常来说，使用 volatile 必须具备以下两个条件：

1. 对变量的写操作不依赖于当前值；
2. 该变量没有包含在具有其他变量的不变式中。

### 状态标记量

### Double-Check(双重检查)



# 3 内存中的对象

![SjiEuGXfWPdNa9F](https://i.loli.net/2021/09/27/SjiEuGXfWPdNa9F.jpg)

## 3.1 对象头

​	Java中任意对象都可以用作锁，因此必定要有一个映射关系，存储该对象以及其对应的锁信息（比如当前哪个线程持有锁，哪些线程在等待）。

![U6MOB7eudymfkF4](https://i.loli.net/2021/09/29/U6MOB7eudymfkF4.jpg)

**Mark Word（标记字段）**：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。

**Klass Point（类型指针）**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。



## 3.2 实例数据

主要存放类的数据信息，父类的信息。



## 3.3 对齐填充

由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。



## AQS

AbstractQueuedSynchronizer，抽象队列同步器。

加锁会导致阻塞，有阻塞就需要排队，实现排队必然需要有某种形式的队列来进行管理。

AQS是一个通过内置的**FIFO**双向队列来完成线程的排队工作(内部通过结点head和tail记录队首和队尾元素，元素的结点类型为Node类型，后面我们会看到Node的具体构造)